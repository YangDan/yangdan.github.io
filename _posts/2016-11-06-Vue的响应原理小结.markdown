---
layout: post
title:  "Vue 1.0的响应原理小结"
date:   2016-11-05 15:40:13 +0530
image: /assets/images/markdown.jpg
headerImage: false
tag:
- vue 响应原理解析 
star: true
category: fontend
author: near
description: Vue  响应原理
---



<h4 style="color:#d9230f;" class="mt20">一 异步DOM队列更新</h4>


&nbsp;&nbsp;&nbsp;&nbsp;再次回去看了看vue的官方文档，发觉文档这种东西每次回去复习都会有新发现。
之前遇到过这样一个问题：

> 对Vue.data里面的变量进行修改，发现视图并没有立即更新，而是等到了页面刷新才会更改视图.

页面刷新等于强制更新视图，当然会导致修改的变量更新，但是按照vue的数据双向绑定响应原理，不该变量变化就立即更新视图吗？答案当然是否定的。。。。。（所以说平时多看文档咯）。

>Vue.js 默认异步更新 DOM。每当观察到数据变化时，Vue 就开始一个队列，将同一事件循环内所有的数据变化缓存起来。如果一个 watcher 被多次触发，只会推入一次到队列中。等到下一次事件循环，Vue 将清空队列，只进行必要的 DOM 更新。在内部异步队列优先使用 MutationObserver，如果不支持则使用 setTimeout(fn, 0)。

以上摘自官方文档－异步更新队列，也就是说只是更新vm.someData = new value,是不会触发dom立即更新的，也就是说你在变量更新后触发的事件也不会使视图更新，需要等到下一次事件循环清空队列时才会更新视图。
这个时候就尴尬了，因为你需要在变量改变后，立即执行视图更新,所以继续往下看：

>为了在数据变化之后等待 Vue.js 完成更新 DOM，可以在数据变化之后立即使用 Vue.nextTick(callback) 。回调在 DOM 更新完成后调用

在这里，你就可以看到他这个全局方法nextTick的作用了！

<h4 style="color:#d9230f;" class="mt20">二 计算属性</h4>

都知道Vue里面有一个选项 computed，为 Vue 实例的计算属性，它可以通过表达式来计算data里面的响应变量，从而来得出一个依赖响应变量的计算变量。<br/>
值得一提的是该计算变量不是每次都会去调用 getter
属性来更新本身的值，它的变化依赖他所计算的 data 中的变量的改变<br/>

>其原理则是因为每次的计算属性都被缓存下来了，只有在依赖发生变化时计算变量才会跟着变化。

计算属性默认是被缓存的，所以他有个设置 cache:false 设置为不缓存，此时就会强制每次计算属性都会去调用getter重新获取该变量<br/>

<p class="mt20">因为官方文档特别说明了这点，所以引起注意，不过我觉得这并没有什么实际意义，设置为不缓存，不仅是性能消耗更高，而且变量还是只会因为他所依赖的data变量改变，在这里就是稍微提一下，所以还是随便别去碰它的默认设置比较好。</p>



